Implement a point to point network with four nodes and duplex links between them analyze the network performance by setting the queue size and varying the band width
set ns [new Simulator]                                            #create a new simulator object

set nf [open "pa1.nam" w] 
$ns namtrace-all $nf                                             #open the nam trace file

set tf [open "pa1.tr" w]
$ns trace-all $tf

proc finish {} {                                                   #define a ‘finish’ procedure  
global ns nf tf
$ns flush-trace
close $nf                                                                 #close the trace file
close $tf
exec nam pa1.nam &
exit 
}
set n0 [$ns node]                                         #create four nodes
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]

$n0 label "UDP0 Source"     
$n1 label "UDP1 Source"
$n3 label "Null"

$ns duplex-link $n0 $n2 1Mb 10ms  DropTail         # create a duplex link between the nodes
$ns duplex-link $n1 $n2 1Mb 5ms  DropTail
$ns duplex-link $n2 $n3 1.4Mb 10ms  DropTail

$ns duplex-link-op $n2 $n3 color "green"
$ns duplex-link-op $n2 $n3 queuePos 3

$ns queue-limit  $n0 $n2 5
$ns queue-limit  $n1 $n2 5
$ns queue-limit  $n2 $n3 20
          set udp0 [new Agent/UDP]            	# attaching transport layer protocols	
		

$ns attach-agent $n0 $udp0
set cbr0 [new Application/Traffic/CBR]     # attaching application layer protocols

$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.005
$cbr0 attach-agent $udp0

set udp1 [new Agent/UDP]
$ns attach-agent $n1 $udp1

set cbr1 [new Application/Traffic/CBR]
$cbr1 set packetSize_ 500
$cbr1 set interval_ 0.005
$cbr1 attach-agent $udp1

set udp2 [new Agent/UDP]
$ns attach-agent $n2 $udp2

set cbr2 [new Application/Traffic/CBR]
$cbr2  attach-agent $udp2

set null0 [new Agent/Null]                                           # creating sink(destination) node
$ns attach-agent $n3 $null0

$ns connect $udp0 $null0
$ns connect $udp1 $null0

$ns at 0.1 "$cbr0 start"
$ns at 0.2 "$cbr1 start"
$ns at 1.0 "finish"

$ns run

(awkf)
BEGIN {
c=0;
}
{
if ($1=="d")
{
c++;
printf("%s\t%s\n",$5,$11);
}
}
END{
printf("The number of packet dropped= %d\n",c);
}









2)
    Implement a point to point network with four nodes and duplex links between them analyze the network performance by setting the queue size and varying the band 
set ns [new Simulator]                                            #create a new simulator object

set nf [open "pa1.nam" w] 
$ns namtrace-all $nf                                             #open the nam trace file

set tf [open "pa1.tr" w]
$ns trace-all $tf

proc finish {} {                                                   #define a ‘finish’ procedure  
global ns nf tf
$ns flush-trace
close $nf                                                                 #close the trace file
close $tf
exec nam pa1.nam &
exit 
}
set n0 [$ns node]                                         #create four nodes
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]

$n0 label "UDP0 Source"     
$n1 label "UDP1 Source"
$n3 label "Null"

$ns duplex-link $n0 $n2 1Mb 10ms  DropTail         # create a duplex link between the nodes
$ns duplex-link $n1 $n2 1Mb 5ms  DropTail
$ns duplex-link $n2 $n3 1.4Mb 10ms  DropTail

$ns duplex-link-op $n2 $n3 color "green"
$ns duplex-link-op $n2 $n3 queuePos 3

$ns queue-limit  $n0 $n2 5
$ns queue-limit  $n1 $n2 5
$ns queue-limit  $n2 $n3 20
          set udp0 [new Agent/UDP]            	# attaching transport layer protocols	
		

$ns attach-agent $n0 $udp0
set cbr0 [new Application/Traffic/CBR]     # attaching application layer protocols

$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.005
$cbr0 attach-agent $udp0

set udp1 [new Agent/UDP]
$ns attach-agent $n1 $udp1

set cbr1 [new Application/Traffic/CBR]
$cbr1 set packetSize_ 500
$cbr1 set interval_ 0.005
$cbr1 attach-agent $udp1

set udp2 [new Agent/UDP]
$ns attach-agent $n2 $udp2

set cbr2 [new Application/Traffic/CBR]
$cbr2  attach-agent $udp2

set null0 [new Agent/Null]                                           # creating sink(destination) node
$ns attach-agent $n3 $null0

$ns connect $udp0 $null0
$ns connect $udp1 $null0

$ns at 0.1 "$cbr0 start"
$ns at 0.2 "$cbr1 start"
$ns at 1.0 "finish"

$ns run

(awk)
BEGIN{udp=0;
tcp=0;
}
{                                                                    
if($1=="r" && $5=="cbr")
{
udp++;
}
else if($1=="r" && $5=="tcp")
{
tcp++;
}
}
END
{
printf("Number of packets sent by TCP=%d\n",tcp);
printf("Number of packets sent by UDP=%d\n",udp);
}








3)
set ns [new Simulator]

set tf [open "lab3.tr" w]
$ns trace-all $tf

set nf [open "lab3.nam" w]
$ns namtrace-all $nf

proc finish { } {
global ns nf tf
$ns flush-trace
close $nf
close $tf
exec nam lab3.nam &
exit 
}


set n0 [$ns node]
$n0 color "red"
set n1 [$ns node]
$n1 color "red"
set n2 [$ns node]
$n2 color "red"
set n3 [$ns node]
$n3 color "red"
set n4 [$ns node]
$n4 color "magenta"
set n5 [$ns node]
$n5 color "magenta"
set n6 [$ns node]
$n6 color "magenta"
set n7 [$ns node]
$n7 color "magenta"

$ns make-lan "$n0 $n1 $n2 $n3" 100Mb 300ms LL Queue/DropTail Mac/802_3
$ns make-lan "$n4 $n5 $n6 $n7" 100Mb 300ms LL Queue/DropTail Mac/802_3
$ns duplex-link $n3 $n4 100Mb 300ms DropTail
$ns duplex-link-op $n3 $n4 color "green"
$ns duplex-link-op $n3 $n4 orient right

set err [new ErrorModel]
$ns lossmodel $err $n3 $n4
$err set rate_ 0.5
set udp [new Agent/UDP]
$ns attach-agent $n1 $udp
set cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp
$cbr set fid_ 0
$cbr set packetSize_ 1000
$cbr set interval_ 0.0001
set null [new Agent/Null]
$ns attach-agent $n7 $null
$ns connect $udp $null

$ns at 0.1 "$cbr start"
$ns at 3.0 "finish"
$ns run


(awk)
BEGIN{
pkt=0;
time=0;
}
{
if($1=="r" && $3=="9" && $4=="7"){
pkt = pkt + $6;
time =$2;
}
}
END {
printf("throughput:%fMbps",(( pkt / time) * (8 / 1000000)));
}








4)
                Implement Ethernet LAN using n nodes and assign multiple traffic to the nodes and obtain congestion window for different sources/destinations.

set ns [new Simulator]
set tf [open "lab4.tr" w]
$ns trace-all $tf

set nf [open "lab4.nam" w]
$ns namtrace-all $nf

proc finish { } {
global ns nf tf
$ns flush-trace
close $tf
close $nf
exec nam lab4.nam &
exit 
}

set n0 [$ns node]
$n0 color "magenta"
$n0 label "src1"
set n1 [$ns node]
set n2 [$ns node]
$n2 color "magenta"
$n2 label "src2"
set n3 [$ns node]
$n3 color "blue"
$n3 label "dest2"
set n4 [$ns node]
set n5 [$ns node]
$n5 color "blue"
$n5 label "dest1"

$ns make-lan "$n0 $n1 $n2 $n3 $n4" 100Mb 100ms LL Queue/DropTail Mac/802_3 

$ns duplex-link $n4 $n5 1Mb 1ms DropTail

set tcp0 [new Agent/TCP]
$ns attach-agent $n0 $tcp0

set ftp0 [new Application/FTP]
$ftp0 attach-agent $tcp0
$ftp0 set packetSize_ 500
$ftp0 set interval_ 0.0001

set sink5 [new Agent/TCPSink]
$ns attach-agent $n5 $sink5
$ns connect $tcp0 $sink5


set tcp2 [new Agent/TCP]
$ns attach-agent $n2 $tcp2

set ftp2 [new Application/FTP]
$ftp2 attach-agent $tcp2
$ftp2 set packetSize_ 600
$ftp2 set interval_ 0.001

set sink3 [new Agent/TCPSink]
$ns attach-agent $n3 $sink3

$ns connect $tcp2 $sink3
set file1 [open file1.tr w]

$tcp0 attach $file1
Set file2 [open file2.tr w]

$tcp2 attach $file2
$tcp0 trace cwnd_ 
$tcp2 trace cwnd_

$ns at 0.1 "$ftp0 start"
$ns at 5 "$ftp0 stop"
$ns at 7 "$ftp0 start"
$ns at 0.2 "$ftp2 start"
$ns at 8 "$ftp2 stop"
$ns at 14 "$ftp0 stop"
$ns at 10 "$ftp2 start"
$ns at 15 "$ftp2 stop"
$ns at 16 "finish"
$ns run



(Awk)
BEGIN {
}
{
if($6=="cwnd_") 
printf(" Time= %f\t congestion window=%f\t\n",$1,$7);
}
END {
}







5)
                       Implement ESS with transmission nodes in wireless LAN and obtain the performance parameters
set ns [new Simulator]

set tf [open lab5.tr w]
$ns trace-all $tf

set topo [new Topography]
$topo load_flatgrid 1000 1000

set nf [open lab5.nam w]
$ns namtrace-all-wireless $nf 1000 1000

$ns node-config -adhocRouting DSDV \
		-llType LL \
		-macType Mac/802_11 \
		-ifqType Queue/DropTail \
		-ifqLen 50 \
		-phyType Phy/WirelessPhy \
		-channelType Channel/WirelessChannel \
		-propType Propagation/TwoRayGround \
		-antType Antenna/OmniAntenna \
		-topoInstance $topo \
		-agentTrace ON \
		-routerTrace ON
create-god 3
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]

$n0 label "tcp0"
$n1 label "sink1/tcp1"
$n2 label "sink2"

$n0 set X_ 50
$n0 set Y_ 50
$n0 set Z_ 0
$n1 set X_ 100
$n1 set Y_ 100
$n1 set Z_ 0
$n2 set X_ 600
$n2 set Y_ 600
$n2 set Z_ 0

$ns at 0.1 "$n0 setdest 50 50 15"
$ns at 0.1 "$n1 setdest 100 100 25"
$ns at 0.1 "$n2 setdest 600 600 25"

set tcp0 [new Agent/TCP]
$ns attach-agent $n0 $tcp0

set ftp0 [new Application/FTP]
$ftp0 attach-agent $tcp0

set sink1 [new Agent/TCPSink]
$ns attach-agent $n1 $sink1
$ns connect $tcp0 $sink1

set tcp1 [new Agent/TCP]
$ns attach-agent $n1 $tcp1

set ftp1 [new Application/FTP]
$ftp1 attach-agent $tcp1

set sink2 [new Agent/TCPSink]
$ns attach-agent $n2 $sink2

$ns connect $tcp1 $sink2
$ns at 5 "$ftp0 start"
$ns at 5 "$ftp1 start"
$ns at 100 "$n1 setdest 550 550 15"
$ns at 190 "$n1 setdest 70 70 15"
proc finish { } {
global ns nf tf 
$ns flush-trace
exec nam lab5.nam & 
close $tf
exit 0
}
$ns at 250 "finish"
$ns run


(Awk)
BEGIN{
count1=0
count2=0
pack1=0
pack2=0
time1=0
time2=0
}
{
if($1=="r"&&$3=="_1_"&&$4=="AGT")
{
count1++
pack1=pack1+$8
time1=$2
}
if($1=="r"&&$3=="_2_"&&$4=="AGT")
{
count2++
pack2=pack2+$8
time2=$2
}
}
END{
printf("The Throughput from n0 to n1:%f Mbps \n",((count1*pack1*8)/(time1*1000000)));
printf("The Throughput from n1 to n2: %f Mbps",((count2*pack2*8)/(time2*1000000)));
}









6)
Implement of link state routing algorithm
set ns [new Simulator]

set nr [open "lab6.tr" w]
$ns trace-all $nr

set nf [open "lab6.nam" w]
$ns namtrace-all $nf

        proc finish { } {
        global ns nr nf
        $ns flush-trace
        close $nf
        close $nr
        exec nam thro.nam &
        exit 0
        }

for { set i 0 } { $i < 12} { incr i 1 } {
set n($i) [$ns node]}

for {set i 0} {$i < 8} {incr i} {
$ns duplex-link $n($i) $n([expr $i+1]) 1Mb 10ms DropTail  }

$ns duplex-link $n0 $n8 1Mb 10ms DropTail
$ns duplex-link $n1 $n10 1Mb 10ms DropTail
$ns duplex-link $n0 $n9 1Mb 10ms DropTail
$ns duplex-link $n9 $n11 1Mb 10ms DropTail
$ns duplex-link $n10 $n11 1Mb 10ms DropTail
$ns duplex-link $n11 $n5 1Mb 10ms DropTail

set udp0 [new Agent/UDP]
$ns attach-agent $n0 $udp0
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 500
$cbr0 set  interval_ 0.005
$cbr0 attach-agent $udp0
set null0 [new Agent/Null]
$ns attach-agent $n5 $null0
$ns connect $udp0 $null0

set udp1 [new Agent/UDP]
$ns attach-agent $n1 $udp1
set cbr1 [new Application/Traffic/CBR]
$cbr1 set packetSize_ 500
$cbr1 set  interval_ 0.005
$cbr1 attach-agent $udp1
set null0 [new Agent/Null]
$ns attach-agent $n5 $null0
$ns connect $udp1 $null0

$ns rtproto LS

$ns rtmodel-at 10.0 down $n11 $n5
$ns rtmodel-at 15.0 down $n7 $n6
$ns rtmodel-at 30.0 up $n11 $n5
$ns rtmodel-at 20.0 up $n7 $n6

$udp0 set fid_ 1
$udp1 set fid_ 2
$ns color 1 "Red"
$ns color 2 "Green"

$ns at 1.0 "$cbr0 start"
$ns at 2.0 "$cbr1 start"

$ns at 45 "finish"
$ns run







                                                PART B
1)
               Bit stuffing
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void main()
{
int i=0,j=0,k,d,ext=8,m;
char a[50]="",flag[]="01111110",temp[50]="";
//printf("enter the data=\n");
//scanf("%s",a);
printf("enter the number of characters\n");
scanf("%d",&m);
printf("\n enter the characters\n");
for(i=0;i<m+1;i++)
{
scanf("%c",&a[i]);
}
printf("\n original data\n");
for(i=0;i<m+1;i++)
printf("%c",a[i]);
strcpy(temp,flag);
for(i=0,j=0;i<strlen(a);i++)
{
if(a[i]=='1')
j++;
else
j=0;
temp[i + ext]=a[i];
if(j==5)
{
++ext;
temp[i+ ext]='0';
j=0;
}
}
strcat(temp,flag);
printf("\nStuffed bit sequence = \n%s",temp);
}







           Character stuffing
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void main()
{
char c[50],d[50],t[50];
int i,m,j;
printf("enter the number of characters\n");
scanf("%d",&m);
printf("\n enter the characters\n");
for(i=0;i<m+1;i++)
{
scanf("%c",&c[i]);
}
printf("\n original data\n");
for(i=0;i<m+1;i++)
printf("%c",c[i]);
d[0]='d';
d[1]='l'; 
d[2]='e';
d[3]='s';
d[4]='t';
d[5]='x';
for(i=0,j=6;i<m+1;i++,j++)
{
	
if((c[i]=='d'&&c[i+1]=='l'&& c[i+2]=='e'))
{
d[j]='d';j++;
d[j]='l'; j++;
d[j]='e'; j++;
m=m+3;
}
d[j]=c[i];
}
m=m+6;
m++;
d[m]='d';m++;
d[m]='l';m++;
d[m]='e';m++;
d[m]='e';m++;
d[m]='t';m++;
d[m]='x';m++;
printf("\n\n transmitted data: \n");
for (i=0;i<m;i++)
{
printf("%c",d[i]);
}
}







2)
          CRC code using CRC-CCITT polynomial

#include<stdio.h>
#include<string.h>
#define N strlen(g)
char t[128], cs[128], g[]="1010",dmy[128];
int a, e, c, b;
void xor()
{
for(c=1; c<N; c++)
cs[c] = ((cs[c] == g[c])? '0' : '1');
}
void crc()
{
for(e=0; e<N; e++)
cs[e] = t[e];
do
{
if(cs[0] == '1')
xor();
for(c=0; c<N-1; c++)
{
cs[c] = cs[c+1];
}
cs[c] = t[e++];
}
while(e<=a+N-1);
}
void main()
{
printf("\nEnter data t: ");
scanf("%s", t);
printf("\nPredefined Generator Polynomial is : %s", g);
a = strlen(t);
for(e=a; e<a+N-1; e++)
t[e] = '0';
printf("\nModified t[u] is : %s", t);
crc();
printf("\nChecksum is : %s", cs);
for(e=a; e<a+N-1; e++)
t[e] = cs[e-a];
printf("\nFinal Codeword is : %s", t);
printf("\n\nTest Error detection 1(yes) 0(no) ? : ");
scanf("%d", &b);
if(b==1)
{
printf("\nEnter position where error is to inserted : ");
scanf("%d", &e);
t[e] = (t[e]=='0')?'1':'0';
printf("Errorneous data : %s\n", t);

crc();
printf("\nChecksum is : %s", cs);

for(e=0; e<N-1; e++)
dmy[e]='0';


if(strcmp(cs,dmy)==0)

printf("\nNo Error Detected.\n");
else
printf("\nError detected.\n");
}
else;
}







3)
          To implement Dijkstra’s algorithm to compute the shortest routing path
#include <stdio.h>
void dijkstra(int n, int v, int cost[10][10], int dist[10], int prevNode[10])
{
int count, u, i, w, visited[10], min;
 for (i = 0; i < n; i++)
{
visited[i] = 0;
dist[i]    = 999;
prevNode[i] = -1;
  if (cost[v][i] < 999) 
{

prevNode[i] = v;
dist[i] = cost[v][i];
 }
 }
 visited[v] = 1;
 dist[v]    = 1;
prevNode[v] = v;
 count      = 2;
 while (count <= n)
{
 min = 999;
for (w = 0; w < n; w++)
  if ((dist[w] <= min) && (visited[w] != 1))
 {
min = dist[w];
    u   = w;
}
visited[u] = 1;
 count++;
  for (w = 0; w < n; w++)
  if ((dist[u] + cost[u][w] < dist[w]) &&
          (visited[w] != 1))  
{
        
dist[w]    = dist[u] + cost[u][w];
        
prevNode[w] = u;
 }
 }
}
void main()
{
int n, v, cost[10][10], dist[10], prevNode[10], i, j;
printf("Enter number of vertices:");
scanf("%d", &n);
printf("\nEnter cost matrix (for infinity, enter 999):\n");
 for (i = 0; i < n; i++)
for (j = 0; j < n; j++)
 scanf("%d", &cost[i][j]);
  printf("\nEnter source vertex:");
  scanf("%d", &v);
dijkstra(n, v, cost, dist, prevNode);
 printf("\nShortest path from \n");
 for (i = 0; i < n; i++)
if (i != v) printf("\n%d -> %d = %d; prev node = %d", v, i, dist[i], prevNode[i]);
printf("\n");
}





















4)              Distance vector algorithm
#include<stdio.h>
#include<stdlib.h>
int main()
{
int d[10][10], t[10][10], a[10][10], i, j, n, k, count;
printf("Enter the number of nodes\n");
scanf("%d", &n);
printf("Enter the initial cost matrix\n");
for(i=1; i<=n; i++)
{
for(j=1; j<=n; j++)
{
scanf("%d", &d[i][j]);
d[i][i] = 0;
t[i][j] = d[i][j];
a[i][j] = j;

}
}
do
{
count = 0;
for(i=1; i<=n; i++)
{
for(j=1; j<=n; j++)
{
for(k=1; k<=n; k++)
{
if(t[i][j]>(d[i][k]+t[k][j]))
{
t[i][j] = (t[i][k] + t[k][j]);
a[i][j] = k;
count++;
}
}
}
}
}
while(count!=0);
for(i=1; i<=n; i++)
{
printf("\n\n For router %d\n", i);
for(j=1; j<=n; j++)
{
printf("\t\nto node %d, via %d, Distance -> %d ",j, a[i][j], t[i][j]);
}
}
printf("\n\n");
return 0;
}





















5)
                     Implementation of stop and wait protocol and sliding window protocol
  #include<stdio.h>

void sender(void);

void receiver(void);

int frame=0,ack=0,frame_no=1;

int lost_frame=1,lost_ack=2;

int seq_no=0,ack_no=0,timer=0,ready=1,max_frames=3;

void main()

{

printf("Enter no of frames\n");

scanf("%d",&max_frames);

while(frame_no<=max_frames)

{

sender();

sleep(2);

if(frame_no==lost_frame)

{

frame=0;

lost_frame=0;

printf("\nFrame %d has been lost\n",frame_no);

}

receiver();

sleep(2);

if((frame_no==lost_ack) && ack==1)

{

ack=0;
lost_ack=0;

printf("\nAck for frame %d has been lost\n",frame_no);

}

if(ack==0)

{

sleep(4);

printf("\nTimer has been expired\n");

timer=1;

}

}

}

void sender(void)

{

if(ready)

{

printf("\nFrame %d is sent with seq no %d\n",frame_no,seq_no);

frame=1;

ready=0;

timer=0;

}

else

{

if(timer==1)

{

printf("\nFrame %d is resent with seq no %d",frame_no,seq_no);

frame=1;

timer=0;

}

if(ack==1)

{

printf("\nAck for frame %d is received\n",frame_no);

seq_no=!seq_no;
ack=0;

frame_no=frame_no+1;

if(frame_no<=max_frames)

{

printf("\nFrame %d is sent with seq no %d\n",frame_no,seq_no);

frame=1;

ready=0;

timer=0;

}

}

}

}

void receiver(void)

{

if(frame==1)

{

frame=0;

if(ack_no==seq_no)

{

ack_no=!ack_no;

printf("\nFrame %d is received and ack with ack no %d is sent\n",frame_no,ack_no);

ack=1;

}

else

{

printf("\nFrame %d is duplicate and discarded ack with ack no %d has been sent\n",frame_no,ack_no);

ack=1;

}

}

}
  





   

6)
           write a program for congestion control using leaky bucket algorithm
#include<stdio.h>
#include<strings.h>
#include<stdio.h>
int min(int x,int y)
{
if(x<y)
return x;
else
return y;
}
int main()
{
int drop=0,mini,nsec,cap,count=0,i,inp[25],process;
syste("clear");
printf("Enter The Bucket Size\n");
scanf("%d",&cap);
printf("Enter The Operation Rate\n");
scanf("%d",&process);
printf("Enter The No. Of Seconds You Want To Stimulate\n");
scanf("%d",&nsec);
for(i=0;i<nsec;i++)
{
printf("Enter The Size Of The Packet Entering At %d
sec\n",i+1);
scanf("%d",&inp[i]);
}
printf("\nSecond|Packet Recieved|Packet Sent|Packet
Left|Packet Dropped|\n");
printf("----------------------------------------------------- ---------\n");
for(i=0;i<nsec;i++)
{
count+=inp[i];
if(count>cap)
{
drop=count-cap;
count=cap;
}
printf("%d",i+1);
printf("\t%d",inp[i]);
mini=min(count,process);
printf("\t\t%d",mini);
count=count-mini;
printf("\t\t%d",count);
printf("\t\t%d\n",drop);
drop=0;
}
for(;count!=0;i++)
{
if(count>cap)
{
drop=count-cap;
count=cap;
}
printf("%d",i+1);
printf("\t0");
mini=min(count,process);
printf("\t\t%d",mini);
count=count-mini;
printf("\t\t%d",count);
printf("\t\t%d\n",drop);
}
}